---
title: "자료구조 기초정리"
date: 2021-06-28 15:20:12 -0400
categories:
---

자료구조 기초 정리

선형구조 : 데이터를 저장할 때 연속적인 기억공간에 배정하는 자료구조
 - 배열
 - 리스트리스트
 - 스택
 - 큐

비선형 구조 : 기억공간 내의 위치와 별개로 독립하여 저장하는 구조
 - 트리
 - 그래프


1. 배열

1) 배열
- 같은 타입의 데이터를 나열한 선형 자료구조
- 연속된 메모리 공간에 순차적으로 저장
- 배열의 크기는 고정. 선언할 때에 배열의 크기를 정하고, 변경 불가

2) 장점
- 인덱스를 가지고있어 바로 접근이 가능함(시간복잡도O(1)), 자료구조의 크기가 클수록 효율적
- 연속된 메모리 공간에 존재하기 때문에 관리가 용이(반복문과 결합하면 정보관리가 효율적)

3) 단점
- 길이를 바꿀수 없으며, 가변 배열의 경우 리소스 낭비가 심함
- 삭제 시 빈 공간이 생겨 메모리가 낭비됨(빈공간을 매꿀때 해당 원소 이후 모든 원소들을 한칸씩 밀거나 당겨야한다.)
- 연속적인 메모리 할당이 필요(메모리 공간을 많이 사용하게 될 수 있음)

4) 사용예
- 데이터의 개수가 확실하게 정해져 있을 때
- 데이터의 삭제와 삽입이 적을 때
- 검색을 해야할 때
- 자료의 인덱스가 중요할 때


2. 리스트

1) 리스트
- 배열이 갖는 인덱스 구조의 장점을 버린 대신 각 데이터의 빈틈을 없앤 자료구조
- 데이터의 삽입과 삭제에 대한 데이터의 낭비를 줄이고, 검색 시간이 길어짐
- 순서가 있는 데이터의 모임
- 리스트에서 인덱스는 몇번째 데이터인가 정도
- 순차성을 보장하지 않음

2) Array List(배열을 이용해 javascript의 배열 구조처럼 리스트를 구현한 것)
- 내부적으로 배열을 사용하기 때문에 인덱스를 이용해 데이터 접근이 가능
- 데이터 조회 속도는 증가하지만 추가, 삭제 속도가 떨어짐

3) Linked List
- 배열을 사용하지 않고, 하나의 데이터에 다음 원소의 위치정보(포인터)를 포함
- 노드를 연결하여 만든 리스트(첫번째노드를 Head, 마지막 노드를 Tail 이라고 함)
- 노드 : 데이터 + 포인터
- 인덱스를 통한 조회가 불가하여 조회 속도가 떨어지지만, 추가, 삭제 시 다른 데이터에 영향을 주지 않기 때문에 상대적으로 빠름

4) 사용예
- 일반적으로 고정된 데이터의 검색이 필요 : Array List
- 검색이 필요없는 가변적인 데이터 : Linked List


3. 선형큐

1) 선형큐
- 선입선출
- 삭제연산만 수행되는 곳을 전단, 프론트(front), 삽입연산만 이루어지는 곳을 후단, 리어(rear)
- 크기가 제한되고 삽입(Enqueue), 삭제(Dequeue) 과정에서 생겨난 빈 공간 사용 시 모든 자료를 꺼내거나 한칸씩 옮겨야 하는 단점이 존재

2) 순환큐
- 선형큐의 문제점을 보완한 큐
- 삭제가 일어날 때마다 원소들의 위치를 바꾸는 것이 아닌 전단과 후단의 위치를 유연하게 옮기는 방식
- Empty 상태를 구분하기 위해 후단을 마지막 데이터의 다음 공간을 가르케게 한다.(전단 = 후단 일 때, Empty상태)
- Full 상태를 구분하기 위해 후단을 위한 더미 공간 하나를 사용(후단 다음노드가 전단일 때, Full상태)

3) 사용예
- 우선순위가 같은 작업 예약(프린터 인쇄 대기열)
- 은행업무
- 콜센터 고객 대기시간
- 프로세스 관리
- 너비 우선 탐색
- 캐시 구현


4. 스택

1) 스택
- 후입선출
- pop : 스택에서 가장 위에있는 항목을 제거
- push : 스택 가장 윗부분에 항목을 추가
- 구조가 단순하여 구현이 쉽다.
- 데이터 저장/읽기 속도가 빠르다.
- 데이터의 최대 저장 갯수를 정해야한다.
- 비어있는 스택에서 원소를 추출하려 할때 stack underflow 발생
- 스택이 넘치는 경우 stack overflow 발생

2) 사용예
- 웹브라우저 방문기록(뒤로가기)
- 역순 문자열 만들기
- 실행취소
- 후위 표기법 계산
- 수식의 괄호 검사


5. 그래프

1) 그래프
- 단순히 노드와 그 노드를 연결하는 엣지를 하나로 모아 놓은 자료구조
- 루트노드 개념이 없음
- 부모-자식의 개념이 없음
- 네트워크 모델

2) 방향성
- 무방향 그래프 : 방향이 없는 간선을 갖으며, 간선은 양방향 관계
- 유방향 그래프 : 방향이 있는 간선을 갖으며, 간선은 단방향 관계

3) 사이클
- 사이클 가능 : 단순 경로의 시작 정점과 종료 정점이 동일
- 자체 간선(self-loof) 가능
- 순환그래프, 비순환그래프 (사이클이 있냐 없냐)

4) 용어
- 정점(vertex): 위치라는 개념 (node)
- 간선(edge):위치 간의 관계 즉 , node를 연결하는 선
- 인접 정점(adjacent vertex): 간선에 의해 직접 연결된 정점
- 정점의 차수(degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수
- 진입 차수(in-degree): 방향 그래프에서 외부에서 오는 간선의 수
- 진출 차수(out-degree): 방향 그래프에서 외부로 향하는 간선의 수
- 경로 길이(path length): 경로를 구성하는 데 사용된 간선의 수
- 단순 경로(simple path): 경로 중에서 반복되는 정점이 없는 경우

5) 그래프의 구현
- 인접 리스트
- 인접 행렬


![그래프의 구현](/assets/img/graph_image_20210628.PNG)


6. 트리

1) 트리
- 방향 그래프
- 비순환 그래프
- 계층 모델
- 사이클 불가능
- 자체 간선(self-loof) 불가능
- 한 개의 루트 노드만이 존재(모든 자식 노드는 한 개의 부모 노드 만을 가짐)
- 부모-자식 관계

2) 용어정리
- 루트 노드(root node): 부모가 없는 노드, 트리는 하나의 루트 노드만을 가진다.
- 단말 노드(leaf node): 자식이 없는 노드, ‘말단 노드’ 또는 ‘잎 노드’라고도 부른다.
- 내부(internal) 노드: 단말 노드가 아닌 노드
- 간선(edge): 노드를 연결하는 선 (link, branch 라고도 부름)
- 형제(sibling): 같은 부모를 가지는 노드
- 노드의 크기(size): 자신을 포함한 모든 자손 노드의 개수
- 노드의 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
- 노드의 레벨(level): 트리의 특정 깊이를 가지는 노드의 집합
- 노드의 차수(degree): 하위 트리 개수 / 간선 수 (degree) = 각 노드가 지닌 가지의 수
- 트리의 차수(degree of tree): 트리의 최대 차수
- 트리의 높이(height): 루트 노드에서 가장 깊숙히 있는 노드의 깊이

---

오늘은 자료구조에 대해 정리했습니다.

정리한 자료구조들 모두 알고는 있지만, 정말 알고는~ 정도의 지식이여서 한번 정리했습니다!

CS의 기초가 많이 약한거 같아 하나씩 차근차근 공부하려 합니다.

그 중 가장 간단하게 정리할 수 있다고 생각한 자료구조를 정말! 간단하게 정리해봤습니다.

사실 제 수준의 개발을 하면서 써봐야 array, list 였습니다... 

직접 경험을 안해보니 머리로는 이해해도 과연 잘 쓸 수 있을지가 의문입니다..

다음 포스팅에는 자바 어레이를 이용해 큐와 스택을 구현해보겠습니다!

감사합니다!
